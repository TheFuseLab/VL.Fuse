shader FuseMap
{

	////////////////////////////////////////////////////////////////
	//
	//          Handy Mapping Functions
	// 			
	////////////////////////////////////////////////////////////////



	////////////////////////////////////////////////////////////////
	//
	//             Bias & Gain
	//
	////////////////////////////////////////////////////////////////


	// Schlick's version of Bias & Gain w/ inversion on 0 to -1 for bias/gain values
	// these functions expect an input in 0 - 1 range

	float bias(float x, float control = 0.5)
	{
		float result = control > 0 ?  (x / ((((1.0/control) - 2.0)*(1.0 - x))+1.0)) :  1-(x / ((((1.0/abs(control)) - 2.0)*(1.0 - x))+1.0));
		return result;
	}

	float2 bias(float2 x, float2 control = 0.5)
	{

		return float2(bias(x.x, control.x), bias(x.y, control.y));
	}

	float3 bias(float3 x, float3 control = 0.5)
	{

		return float3(bias(x.x, control.x), bias(x.y, control.y), bias(x.z, control.z));
	}

	float4 bias(float4 x, float4 control = 0.5)
	{

		return float4(bias(x.x, control.x), bias(x.y, control.y), bias(x.z, control.z), bias(x.w, control.w));
	}



	float gain(float x, float control = 0.5)
	{
		if (control > 0)
		{if(x < 0.5)     return bias(x * 2.0,control)/2.0;   else  return bias(x * 2.0 - 1.0,1.0 - control)/2.0 + 0.5; }
		else if(x < 0.5)     return 1-(bias(x * 2.0,-control)/2.0);   else  return 1-(bias(x * 2.0 - 1.0,1.0 + control)/2.0 + 0.5); 
	} 

	float2 gain(float2 x, float2 control = 0.5)
	{

		return float2(gain(x.x, control.x), gain(x.y, control.y));
	}

	float3 gain(float3 x, float3 control = 0.5)
	{

		return float3(gain(x.x, control.x), gain(x.y, control.y), gain(x.z, control.z));
	}

	float4 gain(float4 x, float4 control = 0.5)
	{

		return float4(gain(x.x, control.x), gain(x.y, control.y), gain(x.z, control.z), gain(x.w, control.w));
	}

	////////////////////////////////////////////////////////////////


	////////////////////////////////////////////////////////////////
	//
	//             Bandpass Functions
	//
	////////////////////////////////////////////////////////////////

	 float smoothstep2 (float onMin, float onMax, float offMin, float offMax, float input)
	 {
		input = smoothstep(onMin, onMax, input) * (1 - smoothstep(offMin, offMax, input));
		return input;
	 }


	float pulse(float input, float center, float slopeWidth, float centerWidth = 0.0)
	{
		centerWidth *= 0.5;
		input = abs(input - center);
		input -= centerWidth;
		if(input > slopeWidth) return 0.0f;
		input /= slopeWidth;
		return 1.0 - input;
	}

	float cubicPulse(float input, float center, float width)
	{
		input = abs(input - center);
		if(input > width) return 0.0f;
		input /= width;
		return 1.0f - input*input*(3.0f-2.0f*input);
	}
	//
	////////////////////////////////////////////////////////////////


	////////////////////////////////////////////////////////////////
	//
	//             Map Functions
	//
	////////////////////////////////////////////////////////////////

	float map(float input, float InMin, float InMax, float OutMin, float OutMax)
	{
		float range = InMax - InMin;
		float normalized = (input - InMin) / range;	
		   return OutMin + normalized * (OutMax - OutMin);
	}
	

	float mapClamp(float input, float InMin, float InMax, float OutMin, float OutMax)
	{
		float range = InMax - InMin;
		float normalized = (input - InMin) / range;	
		float output = OutMin + normalized * (OutMax - OutMin);
		float minV = min(OutMin,OutMax);
		float maxV = max(OutMin, OutMax);
		output = min(max(output, minV), maxV);
		return output ;
	}


	float mapWrap(float input, float InMin, float InMax, float OutMin, float OutMax)
	{
		float range = InMax - InMin;
		float normalized = (input - InMin) / range;	
		float output = OutMin + normalized * (OutMax - OutMin);
		if (normalized < 0) normalized = 1 + normalized;
		return  OutMin + (normalized % 1) * (OutMax - OutMin);
	}


	float mapMirror(float input, float InMin, float InMax, float OutMin, float OutMax)
	{
		float range = InMax - InMin;
		float normalized = (input - InMin) / range;	
		normalized = 1-2*abs(frac(normalized*.5)-.5);
		float output = OutMin + (normalized % 1) * (OutMax - OutMin);
		return output;
	}


	float2 map(float2 input, float2 InMin, float2 InMax, float2 OutMin, float2 OutMax)
	{
		float2 vec;
		vec.x = map( input.x,  InMin.x,  InMax.x,  OutMin.x,  OutMax.x);
		vec.y = map( input.y,  InMin.y,  InMax.y,  OutMin.y,  OutMax.y);
		return vec;
	}

	float3 map(float3 input, float3 InMin, float3 InMax, float3 OutMin, float3 OutMax)
	{
		float3 vec;
		vec.x = map( input.x,  InMin.x,  InMax.x,  OutMin.x,  OutMax.x);
		vec.y = map( input.y,  InMin.y,  InMax.y,  OutMin.y,  OutMax.y);
		vec.z = map( input.z,  InMin.z,  InMax.z,  OutMin.z,  OutMax.z);
		return vec;
	}

	float4 map(float4 input, float4 InMin, float4 InMax, float4 OutMin, float4 OutMax)
	{
		float4 vec;
		vec.x = map( input.x,  InMin.x,  InMax.x,  OutMin.x,  OutMax.x);
		vec.y = map( input.y,  InMin.y,  InMax.y,  OutMin.y,  OutMax.y);
		vec.z = map( input.z,  InMin.z,  InMax.z,  OutMin.z,  OutMax.z);
		vec.w = map( input.w,  InMin.w,  InMax.w,  OutMin.w,  OutMax.w);
		return vec;
	}

	float2 mapClamp(float2 input, float2 InMin, float2 InMax, float2 OutMin, float2 OutMax)
	{
		float2 vec;
		vec.x = mapClamp( input.x,  InMin.x,  InMax.x,  OutMin.x,  OutMax.x);
		vec.y = mapClamp( input.y,  InMin.y,  InMax.y,  OutMin.y,  OutMax.y);
		return vec;
	}

	float3 mapClamp(float3 input, float3 InMin, float3 InMax, float3 OutMin, float3 OutMax)
	{
		float3 vec;
		vec.x = mapClamp( input.x,  InMin.x,  InMax.x,  OutMin.x,  OutMax.x);
		vec.y = mapClamp( input.y,  InMin.y,  InMax.y,  OutMin.y,  OutMax.y);
		vec.z = mapClamp( input.z,  InMin.z,  InMax.z,  OutMin.z,  OutMax.z);
		return vec;
	}

	float4 mapClamp(float4 input, float4 InMin, float4 InMax, float4 OutMin, float4 OutMax)
	{
		float4 vec;
		vec.x = mapClamp( input.x,  InMin.x,  InMax.x,  OutMin.x,  OutMax.x);
		vec.y = mapClamp( input.y,  InMin.y,  InMax.y,  OutMin.y,  OutMax.y);
		vec.z = mapClamp( input.z,  InMin.z,  InMax.z,  OutMin.z,  OutMax.z);
		vec.w = mapClamp( input.w,  InMin.w,  InMax.w,  OutMin.w,  OutMax.w);
		return vec;
	}

	float2 mapWrap(float2 input, float2 InMin, float2 InMax, float2 OutMin, float2 OutMax)
	{
		float2 vec;
		vec.x = mapWrap( input.x,  InMin.x,  InMax.x,  OutMin.x,  OutMax.x);
		vec.y = mapWrap( input.y,  InMin.y,  InMax.y,  OutMin.y,  OutMax.y);
		return vec;
	}

	float3 mapWrap(float3 input, float3 InMin, float3 InMax, float3 OutMin, float3 OutMax)
	{
		float3 vec;
		vec.x = mapWrap( input.x,  InMin.x,  InMax.x,  OutMin.x,  OutMax.x);
		vec.y = mapWrap( input.y,  InMin.y,  InMax.y,  OutMin.y,  OutMax.y);
		vec.z = mapWrap( input.z,  InMin.z,  InMax.z,  OutMin.z,  OutMax.z);
		return vec;
	}

	float4 mapWrap(float4 input, float4 InMin, float4 InMax, float4 OutMin, float4 OutMax)
	{
		float4 vec;
		vec.x = mapWrap( input.x,  InMin.x,  InMax.x,  OutMin.x,  OutMax.x);
		vec.y = mapWrap( input.y,  InMin.y,  InMax.y,  OutMin.y,  OutMax.y);
		vec.z = mapWrap( input.z,  InMin.z,  InMax.z,  OutMin.z,  OutMax.z);
		vec.w = mapWrap( input.w,  InMin.w,  InMax.w,  OutMin.w,  OutMax.w);
		return vec;
	}

	float2 mapMirror(float2 input, float2 InMin, float2 InMax, float2 OutMin, float2 OutMax)
	{
		float2 vec;
		vec.x = mapMirror( input.x,  InMin.x,  InMax.x,  OutMin.x,  OutMax.x);
		vec.y = mapMirror( input.y,  InMin.y,  InMax.y,  OutMin.y,  OutMax.y);
		return vec;
	}

	float3 mapMirror(float3 input, float3 InMin, float3 InMax, float3 OutMin, float3 OutMax)
	{
		float3 vec;
		vec.x = mapMirror( input.x,  InMin.x,  InMax.x,  OutMin.x,  OutMax.x);
		vec.y = mapMirror( input.y,  InMin.y,  InMax.y,  OutMin.y,  OutMax.y);
		vec.z = mapMirror( input.z,  InMin.z,  InMax.z,  OutMin.z,  OutMax.z);
		return vec;
	}

	float4 mapMirror(float4 input, float4 InMin, float4 InMax, float4 OutMin, float4 OutMax)
	{
		float4 vec;
		vec.x = mapMirror( input.x,  InMin.x,  InMax.x,  OutMin.x,  OutMax.x);
		vec.y = mapMirror( input.y,  InMin.y,  InMax.y,  OutMin.y,  OutMax.y);
		vec.z = mapMirror( input.z,  InMin.z,  InMax.z,  OutMin.z,  OutMax.z);
		vec.w = mapMirror( input.w,  InMin.w,  InMax.w,  OutMin.w,  OutMax.w);
		return vec;
	}







};