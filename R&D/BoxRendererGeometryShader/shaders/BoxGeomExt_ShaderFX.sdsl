shader BoxGeomExt_ShaderFX : MaterialExtension, VertexIDStream, ParticleBuffer
{
    cbuffer PerMaterial
    {
        


    }

    stream bool Skip;

    static const float3 QuadPositions[24] = 
    {
        float3(-1, 1, 1),
        float3( 1, 1, 1),
        float3(-1,-1, 1),
        float3( 1,-1, 1),

        float3( 1, 1,-1),
        float3(-1, 1,-1),
        float3( 1,-1,-1),
        float3(-1,-1,-1),

        float3( 1, 1, 1),
        float3(-1, 1, 1),
        float3( 1, 1,-1),
        float3(-1, 1,-1),

        float3(-1,-1, 1),
        float3( 1,-1, 1),
        float3(-1,-1,-1),
        float3( 1,-1,-1),

        float3( 1,-1, 1),
        float3( 1, 1, 1),
        float3( 1,-1,-1),
        float3( 1, 1,-1),

        float3(-1, 1, 1),
        float3(-1,-1, 1),
        float3(-1, 1,-1),
        float3(-1,-1,-1),
    };

    // 24-vertex CCW triangle strip
    float3 CubeVert(in uint vertexID)
    {
        uint b = 1 << vertexID;
        return float3((0xFA55A & b) != 0, (0x5A0F33 & b) != 0, (0x33330F & b) != 0) - 0.5;
    }

    float3 CubeVertArray(in uint vertexID)
    {
        return QuadPositions[vertexID] * 0.5;
    }

    static const float2 QuadUV[4] = 
    {
        float2(0,1), 
        float2(1,1),
        float2(0,0),
        float2(1,0)
    };

    stage override void PreTransformPosition()
    {
    }

    stage override void TransformPosition()
    {
    }

    stage override void PostTransformPosition()
    {
        streams.ShadingPosition = streams.Position;
        AssignVertexID();
        streams.Skip = false;
    }

    void SpawnQuad(uint start, inout TriangleStream<Output> triangleStream, float3 normal, Particle p)
    {
       for(uint i = start; i < start + 4; i++)
       {
            streams.TexCoord  = QuadUV[i % 4].xy;
            float4 posWorld = float4(p.Position, 1);
            float3 qPos = CubeVert(i);
            //float3 qPos = CubeVertArray(i);
            posWorld.xyz += qPos.x * p.AxisX * p.Size3.x;
            posWorld.xyz += qPos.y * p.AxisY * p.Size3.y;
            posWorld.xyz += qPos.z * p.AxisZ * p.Size3.z;
            
            posWorld = mul(posWorld, World);
            
            streams.PositionWS = posWorld;
            streams.normalWS = normal;

            streams.ShadingPosition = mul(posWorld, ViewProjection);
            streams.DepthVS = streams.ShadingPosition.w;
            
            triangleStream.Append(streams);
        }

        triangleStream.RestartStrip();
    }

    [maxvertexcount(12)]
    stage void GSMain(point Input input[1], inout TriangleStream<Output> triangleStream)
    {
        streams = input[0];
        Particle p = Particles[streams.VertexID];
        if (p.Cycle == 0 || p.Age < 0) return;

        float3 viewDir = Eye.xyz;
        
        if (dot(viewDir, p.AxisZ) > 0)
            SpawnQuad(0, triangleStream, p.AxisZ, p);

        if (dot(viewDir, -p.AxisZ) > 0)
            SpawnQuad(4, triangleStream, -p.AxisZ, p);
        
        if (dot(viewDir, p.AxisY) > 0)   
            SpawnQuad(8, triangleStream, p.AxisY, p);
        
        if (dot(viewDir, -p.AxisY) > 0)
            SpawnQuad(12, triangleStream, -p.AxisY, p);
        
        if (dot(viewDir, p.AxisX) > 0)
            SpawnQuad(16, triangleStream, p.AxisX, p);
        
        if (dot(viewDir, -p.AxisX) > 0)
            SpawnQuad(20, triangleStream, -p.AxisX, p);
    }
};