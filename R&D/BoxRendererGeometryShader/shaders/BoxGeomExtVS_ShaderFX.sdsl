shader BoxGeomExtVS_ShaderFX : MaterialExtension, VertexIDStream, ParticleBuffer
{
    cbuffer PerMaterial
    {
    }

    static const float3 QuadPositions[24] = 
    {
        float3(-1, 1, 1),
        float3( 1, 1, 1),
        float3(-1,-1, 1),
        float3( 1,-1, 1),

        float3( 1, 1,-1),
        float3(-1, 1,-1),
        float3( 1,-1,-1),
        float3(-1,-1,-1),

        float3( 1, 1, 1),
        float3(-1, 1, 1),
        float3( 1, 1,-1),
        float3(-1, 1,-1),

        float3(-1,-1, 1),
        float3( 1,-1, 1),
        float3(-1,-1,-1),
        float3( 1,-1,-1),

        float3( 1,-1, 1),
        float3( 1, 1, 1),
        float3( 1,-1,-1),
        float3( 1, 1,-1),

        float3(-1, 1, 1),
        float3(-1,-1, 1),
        float3(-1, 1,-1),
        float3(-1,-1,-1),
    };

    // 24-vertex CCW triangle strip
    float3 CubeVert(in uint vertexID)
    {
        uint b = 1 << vertexID;
        return float3((0xFA55A & b) != 0, (0x5A0F33 & b) != 0, (0x33330F & b) != 0) - 0.5;
    }

    float3 CubeVertArray(in uint vertexID)
    {
        return QuadPositions[vertexID] * 0.5;
    }

    static const float2 QuadUV[4] = 
    {
        float2(0,1), 
        float2(1,1),
        float2(0,0),
        float2(1,0)
    };

    stage override void PreTransformPosition()
    {
    }

    stage override void TransformPosition()
    {
    }

    stage override void PostTransformPosition()
    {
        uint id = streams.VertexID_VS;
        uint vid = id % 12;
        uint iid = id / 12;
        uint nid = vid / 4;

        Particle p = Particles[iid];
        if (p.Cycle == 0 || p.Age < 0) return;

        float3 normals[6];

        normals[0] = p.AxisZ;
        normals[1] = -p.AxisZ;
        normals[2] = p.AxisY;
        normals[3] = -p.AxisY;
        normals[4] = p.AxisX;
        normals[5] = -p.AxisX;

        uint i = vid;
        
        streams.TexCoord  = QuadUV[i % 4].xy;
        float4 posWorld = float4(p.Position, 1);

        float3 qPos = CubeVert(i);

        posWorld.xyz += qPos.x * p.AxisX * p.Size3.x;
        posWorld.xyz += qPos.y * p.AxisY * p.Size3.y;
        posWorld.xyz += qPos.z * p.AxisZ * p.Size3.z;
        
        posWorld = mul(posWorld, World);
        
        streams.PositionWS = posWorld;
        streams.normalWS = normals[nid];

        streams.ShadingPosition = mul(posWorld, ViewProjection);
        streams.DepthVS = streams.ShadingPosition.w;
    }

    stage override void GenerateNormal_VS()
    {
        streams.meshNormalWS = streams.normalWS;
    }
};