shader BSplineMesh_ComputeFX : ComputeShaderBase, Transformation, Camera, BSplineCommon, LineAttributeStream, LineCommon
{
    cbuffer PerDispatch
    {
        stage StructuredBuffer<float3> ControlPointBuffer;
        stage RWStructuredBuffer<Pos3Norm3Col4Tex2> outputBuffer;

        stage int SampleCount;
        stage int Resolution;
        stage bool IsClose;

        stage int ThicknessSpace = 0;
        stage int MeshType = 0;
        stage float4x4 Transform;

        stage int LineCount;
        stage int CtrlPtCount;
    }

    compose ComputeFloat Width;
    compose ComputeFloat4 Color;

    override void Compute()
    {
        uint dtid = streams.DispatchThreadId.x;
        if(dtid >= (SampleCount + IsClose) * LineCount) return;

        int SegmentCount = SampleCount + IsClose;

        uint lineId = streams.LineId = dtid / SegmentCount;
        uint segmentId = streams.SegmentId = dtid % SegmentCount;

        float t = segmentId * (CtrlPtCount-(1-IsClose)) / ((float)SegmentCount-1);
        t = segmentId == SampleCount? .0 : t;

        PointAttribute p = SampleBSpline(ControlPointBuffer, t, lineId, CtrlPtCount, IsClose);
        float3 pos = mul(float4(p.p, 1), Transform).xyz;
        float3 tan = mul(p.t, (float3x3)Transform).xyz;

        streams.LinePosition = pos;

        float3 viewDir = ViewInverse[3].xyz - pos;
        float3 viewFront = ViewInverse[2].xyz;

        float scale = ThicknessSpace == 1 ? dot(viewFront, viewDir)/min(ViewSize.x,ViewSize.y) : 1;
        scale *= Width.Compute();

        if(MeshType == 0) // Ribbon Triangle Strip
        {
            FlatMeshLineStrip(outputBuffer, dtid - lineId, segmentId, pos, tan, scale, Color.Compute(),
                        SegmentCount, normalize(viewDir));
        }
        else // Tube Triangle List
        {
            TubeMeshLineStrip(outputBuffer, dtid - lineId, segmentId, pos, tan, scale, Color.Compute(), 
                        SegmentCount, Resolution);
        }
    }
};