shader FuseRayMarchFunctions : ShaderBaseStream, Transformation, Texturing, PositionStream4, NormalStream
{

	float3 setupRayByCamera(out float3 direction)
	{	
		float2 uv = streams.TexCoord;
		direction = normalize(mul(float4(mul(float4((uv.xy*2-1)*float2(1,-1),0,1),ProjectionInverse).xy,-1,0),ViewInverse).xyz);
		return ViewInverse[3].xyz;
	}

	// https://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm
	float2 cullRayByBox(float3 ro, float3 rd, float3 radius = 2.)  // bounding box
	{
		float3 m = 1.0 / rd;
		float3 n = m * ro;
		float3 k = abs(m) * radius;
		float3 t1 = -n - k;
		float3 t2 = -n + k;

		float tN = max( max( t1.x, t1.y ), t1.z );
		float tF = min( min( t2.x, t2.y ), t2.z );
	
		if( tN > tF || tF < 0.0) discard; // kill ray
		tN = max(tN, 0); // avoid starting our ray behind us
		//return float2( 0.01, 200 );
		return float2(tN, tF);
	}

	float SDF(float3 p){
		return length(p) - 0.5;
	}

	// just generate normals with central difference
	float3 SDFNormal(float3 p, float e = 0.01)
	{
		float3 gradient = float3 (	(SDF(p + float3(e,0,0)) - SDF(p - float3(e,0,0))) / (2*e), 
									(SDF(p + float3(0,e,0)) - SDF(p - float3(0,e,0))) / (2*e), 
									(SDF(p + float3(0,0,e)) - SDF(p - float3(0,0,e))) / (2*e)	);
		return normalize(gradient+0.0000001);

	}

	float3 marchRay(float3 ro, float3 rd, out float3 sn, float2 minMaxDist = float2(.05, 100), int maxIter = 180)
	{
		float3 startPos = ro + rd * minMaxDist.x;
		float3 p = startPos;
		float z = minMaxDist.x;
		//minMaxDist.y -= minMaxDist.x;
		for(int i=0; i<maxIter; i++)
		{
			float dist = SDF(p);
			p += rd * dist;	
			z += dist;
			if(abs(dist) < 0.0001 * z || z > minMaxDist.y) break;
		}

		if(z > minMaxDist.y) discard;
		sn = SDFNormal(p);
		return p;
	}
};